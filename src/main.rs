#[macro_use]
extern crate clap;
extern crate config;
extern crate ctrlc;
extern crate failure;
extern crate fuser;
extern crate gcsf;
#[macro_use]
extern crate log;
extern crate itertools;
extern crate pretty_env_logger;
extern crate rust_embed;
extern crate serde;
extern crate serde_json;
extern crate xdg;

use clap::App;
use failure::{err_msg, Error};
use itertools::Itertools;
use rust_embed::RustEmbed;
use std::ffi::OsStr;
use std::fs;
use std::io::prelude::*;
use std::iter;
use std::sync::atomic::{AtomicBool, Ordering};
use std::sync::Arc;
use std::thread;
use std::time;

use gcsf::{Config, DriveFacade, Gcsf, NullFs};

const DEBUG_LOG: &str =
    "hyper::client=info,hyper::http=info,hyper::net=info,rustls::client::hs=info,debug";

const INFO_LOG: &str =
    "hyper::client=error,hyper::http=error,hyper::net=error,fuser::session=error,info";

const DEFAULT_CONFIG_FILE: &str = "sample_config.toml";

#[derive(RustEmbed)]
#[folder = "data/"]
struct Asset;

fn mount_gcsf(config: Config, mountpoint: &str) {
    let vals = config.mount_options();
    let options = iter::repeat("-o")
        .interleave_shortest(vals.iter().map(String::as_ref))
        .take(2 * vals.len())
        .map(OsStr::new)
        .collect::<Vec<_>>();

    debug!("Mount options: {:#?}", options);

    if config.mount_check() {
        match fuser::spawn_mount(NullFs {}, &mountpoint, &options) {
            Ok(_session) => {
                info!("Test mount of NullFs successful. Will mount GCSF next.");
            }
            Err(e) => {
                error!("Could not mount NullFs to {}: {}", &mountpoint, e);
                return;
            }
        };
    }

    info!("Creating and populating file system...");
    let fs: Gcsf = match Gcsf::with_config(config) {
        Ok(fs) => fs,
        Err(e) => {
            error!("Could not create GCSF instance: {}", e);
            return;
        }
    };

    info!("File system created.");
    info!("Mounting to {}", &mountpoint);
    match fuser::spawn_mount(fs, &mountpoint, &options) {
        Ok(_session) => {
            info!("Mounted to {}", &mountpoint);

            let running = Arc::new(AtomicBool::new(true));
            let r = running.clone();

            ctrlc::set_handler(move || {
                info!("Ctrl-C detected");
                r.store(false, Ordering::SeqCst);
            })
            .expect("Error setting Ctrl-C handler");

            while running.load(Ordering::SeqCst) {
                thread::sleep(time::Duration::from_millis(50));
            }
        }
        Err(e) => error!("Could not mount to {}: {}", &mountpoint, e),
    };
}

fn login(config: &mut Config) -> Result<(), Error> {
    debug!("{:#?}", &config);

    if config.token_file().exists() {
        return Err(err_msg(format!(
            "token file {:?} already exists.",
            config.token_file()
        )));
    }

    // Create a DriveFacade which will store the authentication token in the desired file.
    // And make an arbitrary request in order to trigger the authentication process.
    let mut df = DriveFacade::new(&config);
    let _result = df.root_id();

    Ok(())
}

fn load_conf() -> Result<Config, Error> {
    let xdg_dirs = xdg::BaseDirectories::with_prefix("gcsf")?;
    let path = xdg_dirs
        .place_config_file("gcsf.toml")
        .map_err(|_| err_msg("Cannot create configuration directory"))?;

    info!("Config path: {:?}", &path);
    if !path.exists() {
        let sample_config =
            Asset::get(DEFAULT_CONFIG_FILE).expect("Could not load sample config asset.");

        let mut f = fs::File::create(path.clone())?;
        f.write_all(sample_config.as_ref())?;
    }

    if let Some(filename) = path.to_str() {
        let mut settings = config::Config::default();
        settings
            .merge(config::File::with_name(filename))
            .expect("Invalid configuration file");

        let mut config = settings.try_into::<Config>()?;
        config.config_dir = Some(xdg_dirs.get_config_home());
        Ok(config)
    } else {
        Err(err_msg("Config file path is not valid unicode!"))
    }
}

fn main() {
    // Load config. Any logs generated by this call will unfortunately not show up because the
    // global logger is not initialized yet. It is not possible to initialize it twice (DEBUG_LOG
    // first and then adjust based on config) so this will have to do for now.
    let mut config = load_conf().expect("Could not load configuration file.");

    pretty_env_logger::formatted_builder()
        .parse_filters(if config.debug() { DEBUG_LOG } else { INFO_LOG })
        .format_timestamp_secs()
        .init();
    info!("Debug mode: {:?}.", config.debug());

    let yaml = load_yaml!("cli.yml");
    let matches = App::from_yaml(yaml).get_matches();

    if let Some(matches) = matches.subcommand_matches("login") {
        config.session_name = Some(matches.value_of("session_name").unwrap().to_string());

        match login(&mut config) {
            Ok(_) => {
                println!(
                    "Successfully logged in. Saved credentials to {:?}",
                    &config.token_file()
                );
            }
            Err(e) => {
                error!("Could not log in: {}", e);
            }
        };
    }

    if let Some(matches) = matches.subcommand_matches("logout") {
        config.session_name = Some(matches.value_of("session_name").unwrap().to_string());
        let tf = config.token_file();
        match fs::remove_file(&tf) {
            Ok(_) => {
                println!("Successfully removed {:?}", &tf);
            }
            Err(e) => {
                println!("Could not remove {:?}: {}", &tf, e);
            }
        };
    }

    if let Some(_matches) = matches.subcommand_matches("list") {
        let exception = String::from("gcsf.toml");
        let mut sessions: Vec<_> = fs::read_dir(&config.config_dir())
            .expect(&format!(
                "Could not read config dir: {:?}",
                &config.config_dir()
            ))
            .map(Result::unwrap)
            .map(|f| f.file_name().to_str().unwrap().to_string())
            .filter(|name| name != &exception)
            .collect();
        sessions.sort();

        if sessions.is_empty() {
            println!("No sessions found.");
        } else {
            println!("Sessions:");
            for session in sessions {
                println!("\t- {}", &session);
            }
        }
    }

    if let Some(matches) = matches.subcommand_matches("mount") {
        let mountpoint = matches.value_of("mountpoint").unwrap();
        config.session_name = Some(matches.value_of("session_name").unwrap().to_string());

        if !config.token_file().exists() {
            error!("Token file {:?} does not exist.", config.token_file());
            error!("Try logging in first using `gcsf login`.");
            return;
        }

        if config.client_secret.is_none() {
            error!("No Google OAuth client secret was provided.");
            error!("Try deleting your config file to force GCSF to generate it with the default credentials.");
            error!("Alternatively, you can create your own credentials or manually set the default ones from https://github.com/harababurel/gcsf/blob/master/data/sample_config.toml");
            return;
        }

        mount_gcsf(config, mountpoint);
    }
}
